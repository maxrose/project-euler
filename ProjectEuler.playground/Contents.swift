//: Playground - noun: a place where people can play

import Foundation

print("Welcome to Max's Project Euler playground")

struct ProblemSelection : OptionSet {
    let rawValue: Int
    
    static let none      = ProblemSelection(rawValue: 0)
    static let problem1  = ProblemSelection(rawValue: 1 << 0)
    static let problem2  = ProblemSelection(rawValue: 1 << 1)
    static let problem3  = ProblemSelection(rawValue: 1 << 2)
    static let problem4  = ProblemSelection(rawValue: 1 << 3)
    static let problem5  = ProblemSelection(rawValue: 1 << 4)
    static let problem6  = ProblemSelection(rawValue: 1 << 5)
    static let problem7  = ProblemSelection(rawValue: 1 << 6)
    static let problem8  = ProblemSelection(rawValue: 1 << 7)
    static let problem9  = ProblemSelection(rawValue: 1 << 8)
    static let problem10 = ProblemSelection(rawValue: 1 << 9)
    
    static let all: ProblemSelection = [.problem1, .problem2, .problem3, .problem4, .problem5,
                                        .problem6, .problem7, .problem8, .problem9, .problem10]
}
// To save a little recomputation time, select the problems you'd like to see with the mask
let problemMask: ProblemSelection = .problem9//[.problem1, .problem2, .problem3, .problem4, .problem5]

// Utility functions.

// Returns an array of prime factors. The array should be in accending order.
// As a side effect of finding the factors this function creates a list of primes up to the value of num.
// This is an area for optimization with caching.
func primeFactorsOf(_ num: Int) -> Array<Int> {
    // Discover primes
    var primes = Array<Int>()
    var currentExamination = 2
    if primes.count > 0 {
        currentExamination = primes.last!+1
    }
    // Check factor
    var factors = Array<Int>()
    var currentVal = num
    
    while (currentExamination <= currentVal && (primes.count == 0 || currentVal >= primes.first!)) {
        var isPrime = true
        for prime in primes {
            if currentExamination % prime == 0 {
                isPrime = false
                break
            }
        }
        if isPrime {
            primes.append(currentExamination)
            while currentVal % currentExamination == 0 {
                factors.append(currentExamination)
                currentVal /= currentExamination
            }
        }
        currentExamination += 1
    }
    return factors
}

// Returns the value of base raised to exponenet
func intPower(_ base: Int, _ exponent: Int) -> Int {
    return Int(pow(Double(base),Double(exponent)))
}

// Prints out formatted outputs.
func printTestCase(_ result: Any) {
    print("Sample case result:", result)
}
func printResultCase(_ result: Any) {
    print("Application result:", result)
}

// Problem 1
if problemMask.contains(.problem1) {
    print("\nProblem 1")
    
    print("If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.")
    print("Find the sum of all the multiples of 3 or 5 below 1000.")
    func sumOfProducts(baseValues: Set<Int>, limit: Int) -> Int {
        var multiples = Set<Int>()
        
        for baseValue in baseValues {
            var multiple = baseValue
            while multiple < limit {
                multiples.insert(multiple)
                multiple += baseValue
            }
        }
        
        var sum = 0
        for product in multiples {
            sum += product
        }
        return sum
    }
    
    printTestCase(sumOfProducts(baseValues: Set([3,5]), limit: 10))
    printResultCase(sumOfProducts(baseValues: Set([3,5]), limit: 1000))
}

// Problem 2
if problemMask.contains(.problem2) {
    print("\nProblem 2")
    
    print("Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:")
    print("    1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...")
    print("By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.")
    
    func sumNumbersAndReturnEvenUnderLimit(num1: Int, num2: Int, lim: Int) -> Int {
        let next: Int = num1 + num2
        var sum = 0
        if (num2 % 2 == 0) {
            sum += num2
        }
        if (next < lim) {
            sum += sumNumbersAndReturnEvenUnderLimit(num1: num2, num2: next, lim: lim)
        }
        return sum
    }
    
    printTestCase(sumNumbersAndReturnEvenUnderLimit(num1: 1, num2: 2, lim: 90))
    printResultCase(sumNumbersAndReturnEvenUnderLimit(num1: 1, num2: 2, lim: 4000000))
}

// Problem 3
if problemMask.contains(.problem3) {
    print("\nProblem 3")
    
    print("The prime factors of 13195 are 5, 7, 13 and 29.")
    print("What is the largest prime factor of the number 600851475143?")
    
    func largestPrimeFactorOf(_ num: Int) -> Int {
        var primeFactors = primeFactorsOf(num)
        primeFactors.sort(by:>)
        return primeFactors.first!
    }
    
    printTestCase(largestPrimeFactorOf(13195))
    printResultCase(largestPrimeFactorOf(600851475143))
}

// Problem 4
if problemMask.contains(.problem4) {
    print("\nProblem 4")
    
    print("A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.")
    print("Find the largest palindrome made from the product of two 3-digit numbers.")
    
    func reverseDigits(_ num: Int, base: Int) -> Int {
        var reversed = 0
        var placeholder = num
        
        while placeholder >= 1 {
            reversed = (reversed * base) + (placeholder % base)
            placeholder /= base
        }
        return reversed
    }
    
    func isPalindrome(_ num: Int, base: Int) -> Bool {
        if num < 10 {
            return true
        }
        
        if num % base == 0 {
            return false
        }
        
        if num == reverseDigits(num, base: base) {
            return true
        }
        return false
    }
    
    func largestPalindromicProduct(numDigits: Int, base: Int=10) -> Int {
        var maxPalindrome = 0;
        let bottomLimit = intPower(base, numDigits-1)-1
        let upperLimit = intPower(base, numDigits)-1
        
        var a = upperLimit
        while (a > bottomLimit) {
            var b = upperLimit
            while (b >= a) {
                let product = a*b
                if (product > maxPalindrome && isPalindrome(product, base: base)) {
                    maxPalindrome = product
                }
                b -= 1
            }
            a -= 1
        }
        
        return maxPalindrome
    }
    
    printTestCase(largestPalindromicProduct(numDigits: 2))
    print("Application Result:  ", largestPalindromicProduct(numDigits: 3))
}

// Problem 5
if problemMask.contains(.problem5) {
    print("\nProblem 5")
    
    print("2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.")
    print("What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?")
    func smallestNumberDivisibleByValuesUpTo(_ limit: Int) -> Int {
        var primeFactors = Dictionary<Int, Int>()
        // Not sure if this stride should be inclusive of the limit.
        // The test case given would be agnostic towards this.
        for value in stride(from: 2, through: limit, by: 1) {
            var primeFactorCount = Dictionary<Int, Int>()
            for primeFactor in primeFactorsOf(value) {
                // Can this check be shrunk with swift syntax magic?
                if primeFactorCount[primeFactor] == nil {
                    primeFactorCount[primeFactor] = 1
                }
                else {
                    primeFactorCount[primeFactor] = primeFactorCount[primeFactor]! + 1
                }
            }
            for key in primeFactorCount.keys {
                // Same potential optimization as above.
                if primeFactors[key] == nil {
                    primeFactors[key] = primeFactorCount[key]
                }
                else {
                    primeFactors[key] = max(primeFactors[key]!, primeFactorCount[key]!)
                }
            }
        }
        
        var product = 1
        for prime in primeFactors.keys {
            product *= intPower(prime, primeFactors[prime]!)
        }
        return product
    }
    
    printTestCase(smallestNumberDivisibleByValuesUpTo(10))
    printResultCase(smallestNumberDivisibleByValuesUpTo(20))
}

// Problem 6
if problemMask.contains(.problem6) {
    print("\nProblem 6")
    print("The sum of the squares of the first ten natural numbers is, 1^2 + 2^2 + ... + 10^2 = 385")
    print("The square of the sum of the first ten natural numbers is, (1 + 2 + ... + 10)^2 = 55^2 = 3025")
    print("Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 − 385 = 2640.")
    print("Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.")
    
    func sumSquares(_ values: Array<Int>) -> Int {
        return values.reduce(0, { $0 + $1*$1 });
    }
    
    func squareSum(_ values: Array<Int>) -> Int {
        let sum = values.reduce(0, +)
        return sum * sum
    }
    
    func differenceOfSquaresUpTo(_ cap: Int) -> Int {
        let values = Array<Int>(1...cap)
        return squareSum(values) - sumSquares(values)
    }
    
    printTestCase(differenceOfSquaresUpTo(10))
    printResultCase(differenceOfSquaresUpTo(100))
}

// Problem 7
if problemMask.contains(.problem7) {
    print("\nProblem 7")
    print("By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.")
    print("What is the 10 001st prime number?")
    
    func nthPrime(_ n: Int) -> Int {
        var primes = [Int]()
        var i = 2
        while primes.count < n {
            var isPrime = true
            for p in primes {
                if i % p == 0 {
                    isPrime = false
                    break
                }
            }
            if isPrime {
                primes.append(i)
            }
            i += 1
        }
        
        return primes.last!
    }
    
    printTestCase(nthPrime(6)) // 13
    printResultCase(nthPrime(10001)) // 104743
}

// Problem 8
if problemMask.contains(.problem8) {
    print("\nProblem 8")
    print("Number: 73167176531330624919225119674426574742355349194934...");
    print("The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.")
    print("Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?")
    
    // Can't store the 1000 digit number as an int.
    let largeDigitNumber = "7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450"
    
    func largestProductOfContinuousDigits(_ digitCount: Int , _ n: String) -> Int {
        var maxProduct = 0
        var startIndex = 0
        
        while startIndex + digitCount <= n.characters.count {
            let start = n.index(n.startIndex, offsetBy: startIndex)
            let stop  = n.index(n.startIndex, offsetBy: startIndex + digitCount)
            let slice = n.substring(with: Range(start..<stop))
            
            var consecutiveDigits = Int(slice)!
            var product = 1
            while consecutiveDigits >= 1 {
                product *= consecutiveDigits % 10
                consecutiveDigits /= 10
            }
            maxProduct = max(maxProduct, product)
            
            startIndex += 1
        }
        
        return maxProduct
    }
    
    printTestCase(largestProductOfContinuousDigits(4, largeDigitNumber))
    printResultCase(largestProductOfContinuousDigits(13, largeDigitNumber))
}

// Problem 9
if problemMask.contains(.problem9) {
    print("\nProblem 9")
    print("A Pythagorean triplet is a set of three natural numbers, a < b < c, for which, a^2 + b^2 = c^2")
    print("For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.")
    print("There exists exactly one Pythagorean triplet for which a + b + c = 1000.")
    print("Find the product abc.")
    
    func isPythagoreanTriplet(_ nums: Array<Int>) -> Bool {
        if nums.count != 3 {
            return false
        }
        return nums[0]*nums[0] + nums[1]*nums[1] == nums[2]*nums[2]
    }
    
    func findPythagorianTripletsThatSumsTo(_ n: Int) -> Array<Array<Int>> {
        var triplets = Array<Array<Int>>()
        for a in Int(sqrt(Double(n)))...n/3 {
            for b in max((n/2-a), a)...n/2 {
                let c = n - a - b
                let triplet = [a,b,c]
                if isPythagoreanTriplet(triplet) {
                    triplets.append(triplet)
                    break
                }
            }
            if triplets.count > 0 {
                break
            }
        }
        return triplets
    }
    
    printTestCase(findPythagorianTripletsThatSumsTo(12))
    printResultCase(findPythagorianTripletsThatSumsTo(1000))
}

//// Problem 10
//if problemMask.contains(.problem10) {
//    print("\nProblem 10")
//    print("The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.")
//    print("Find the sum of all the primes below two million.")
//    
//    func sumPrimesBelow(_ limit: Int) -> Int {
//        return 0
//    }
//    
//    printTestCase(sumPrimesBelow(12))
//    printResultCase(sumPrimesBelow(1000))
//}
