//: Playground - noun: a place where people can play

import Foundation

print("Welcome to Max's Project Euler playground")

struct ProblemSelection : OptionSet {
    let rawValue: Int
    
    static let none     = ProblemSelection(rawValue: 0)
    static let problem1 = ProblemSelection(rawValue: 1 << 0)
    static let problem2 = ProblemSelection(rawValue: 1 << 1)
    static let problem3 = ProblemSelection(rawValue: 1 << 2)
    static let problem4 = ProblemSelection(rawValue: 1 << 3)
    static let problem5 = ProblemSelection(rawValue: 1 << 4)
    
    static let all: ProblemSelection = [.problem1, .problem2, .problem3, .problem4, .problem5]
}
// To save a little recomputation time, select the problems you'd like to see with the mask
let problemMask: ProblemSelection = [.problem1, .problem2, .problem3, .problem4, .problem5]


// Utility functions.

// Returns an array of prime factors. The array should be in accending order.
// As a side effect of finding the factors this function creates a list of primes up to the value of num.
// This is an area for optimization with caching.
func primeFactorsOf(_ num: Int) -> Array<Int> {
    // Discover primes
    var primes = Array<Int>()
    var currentExamination = 2
    if primes.count > 0 {
        currentExamination = primes.last!+1
    }
    // Check factor
    var factors = Array<Int>()
    var currentVal = num
    
    while (currentExamination <= currentVal && (primes.count == 0 || currentVal >= primes.first!)) {
        var isPrime = true
        for prime in primes {
            if currentExamination % prime == 0 {
                isPrime = false
                break
            }
        }
        if isPrime {
            primes.append(currentExamination)
            while currentVal % currentExamination == 0 {
                factors.append(currentExamination)
                currentVal /= currentExamination
            }
        }
        currentExamination += 1
    }
    return factors
}

// Returns the value of base raised to exponenet
func intPower(_ base: Int, _ exponent: Int) -> Int {
    return Int(pow(Double(base),Double(exponent)))
}

// Problem 1
if problemMask.contains(.problem1) {
    print("\nProblem 1")
    
    print("If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.")
    print("Find the sum of all the multiples of 3 or 5 below 1000.")
    func sumOfProducts(baseValues: Set<Int>, limit: Int) -> Int {
        var multiples = Set<Int>()
        
        for baseValue in baseValues {
            var multiple = baseValue
            while multiple < limit {
                multiples.insert(multiple)
                multiple += baseValue
            }
        }
        
        var sum = 0
        for product in multiples {
            sum += product
        }
        return sum
    }
    
    print("Example's test case:", sumOfProducts(baseValues: Set([3,5]), limit: 10))
    print("Application Result: ", sumOfProducts(baseValues: Set([3,5]), limit: 1000))
}

// Problem 2
if problemMask.contains(.problem2) {
    print("\nProblem 2")
    
    print("Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:")
    print("    1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...")
    print("By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.")
    
    func sumNumbersAndReturnEvenUnderLimit(num1: Int, num2: Int, lim: Int) -> Int {
        let next: Int = num1 + num2
        var sum = 0
        if (num2 % 2 == 0) {
            sum += num2
        }
        if (next < lim) {
            sum += sumNumbersAndReturnEvenUnderLimit(num1: num2, num2: next, lim: lim)
        }
        return sum
    }
    
    print("Example's test case:", sumNumbersAndReturnEvenUnderLimit(num1: 1, num2: 2, lim: 90))
    print("Application Result: ", sumNumbersAndReturnEvenUnderLimit(num1: 1, num2: 2, lim: 4000000))
}

// Problem 3
if problemMask.contains(.problem3) {
    print("\nProblem 3")
    
    print("The prime factors of 13195 are 5, 7, 13 and 29.")
    print("What is the largest prime factor of the number 600851475143?")
    
    func largestPrimeFactorOf(_ num: Int) -> Int {
        var primeFactors = primeFactorsOf(num)
        primeFactors.sort(by:>)
        return primeFactors.first!
    }
    
    print("Example's test case:", largestPrimeFactorOf(13195))
    print("Application Result: ", largestPrimeFactorOf(600851475143))
}

// Problem 4
if problemMask.contains(.problem4) {
    print("\nProblem 4")
    
    print("A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 Ã— 99.")
    print("Find the largest palindrome made from the product of two 3-digit numbers.")
    
    func reverseDigits(_ num: Int, base: Int) -> Int {
        var reversed = 0
        var placeholder = num
        
        while placeholder >= 1 {
            reversed = (reversed * base) + (placeholder % base)
            placeholder /= base
        }
        return reversed
    }
    
    func isPalindrome(_ num: Int, base: Int) -> Bool {
        if num < 10 {
            return true
        }
        
        if num % base == 0 {
            return false
        }
        
        if num == reverseDigits(num, base: base) {
            return true
        }
        return false
    }
    
    func largestPalindromicProduct(numDigits: Int, base: Int=10) -> Int {
        var maxPalindrome = 0;
        let bottomLimit = intPower(base, numDigits-1)-1
        let upperLimit = intPower(base, numDigits)-1
        
        var a = upperLimit
        while (a > bottomLimit) {
            var b = upperLimit
            while (b >= a) {
                let product = a*b
                if (product > maxPalindrome && isPalindrome(product, base: base)) {
                    maxPalindrome = product
                }
                b -= 1
            }
            a -= 1
        }
        
        return maxPalindrome
    }
    
    print("Example's test case:", largestPalindromicProduct(numDigits: 2))
    print("Application Result:  ", largestPalindromicProduct(numDigits: 3))
}

// Problem 5
if problemMask.contains(.problem5) {
    print("\nProblem 5")
    
    print("2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.")
    print("What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?")
    func smallestNumberDivisibleByValuesUpTo(_ limit: Int) -> Int {
        var primeFactors = Dictionary<Int, Int>()
        // Not sure if this stride should be inclusive of the limit.
        // The test case given would be agnostic towards this.
        for value in stride(from: 2, through: limit, by: 1) {
            var primeFactorCount = Dictionary<Int, Int>()
            for primeFactor in primeFactorsOf(value) {
                // Can this check be shrunk with swift syntax magic?
                if primeFactorCount[primeFactor] == nil {
                    primeFactorCount[primeFactor] = 1
                }
                else {
                    primeFactorCount[primeFactor] = primeFactorCount[primeFactor]! + 1
                }
            }
            for key in primeFactorCount.keys {
                // Same potential optimization as above.
                if primeFactors[key] == nil {
                    primeFactors[key] = primeFactorCount[key]
                }
                else {
                    primeFactors[key] = max(primeFactors[key]!, primeFactorCount[key]!)
                }
            }
        }
        
        var product = 1
        for prime in primeFactors.keys {
            product *= intPower(prime, primeFactors[prime]!)
        }
        return product
    }
    
    print("Example's test case:", smallestNumberDivisibleByValuesUpTo(10))
    print("Application Result: ", smallestNumberDivisibleByValuesUpTo(20))
}